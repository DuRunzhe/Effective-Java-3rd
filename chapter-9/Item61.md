# 优先选择原生类型而非包装类型

Java有两部分类型系统，分别是原生类型（如`int`、`double`与`boolean`等）和引用类型（如`String`与`List`等）。每个原生类型都有一个对应的引用类型，称之为包装类型。对应于`int`、`double`与`boolean`的包装类型分别是`Integer`、`Double`与`Boolean`。

正如条款6所述，自动装箱与自动拆箱之间的界限并不是那么明确，不过这并不会消除原生类型与包装类型之间的区别。这两种类型之间存在着真实的差别，意识到使用的是哪一种以及在这两者之间进行谨慎的选择是非常重要的。

原生类型与包装类型之间存在3个主要的差别。首先，原生类型只有值，而包装类型则拥有与其值不同的身份。换句话说，两个包装类型实例可以拥有相同的值，但身份却不同。其次，原生类型只有功能完善的值，而每个包装类型除了对应的原生类型所有的功能性值之外，还有一个非功能性值，即`null`。最后，相比于包装类型来说，原生类型在时间与空间上的效率更高。如果不加注意，那么这3个差别将会使你陷入到麻烦当中。

考虑下面的比较器，它设计的目的是对`Integer`类型的值进行升序排序。回想一下，`Comparator`的`compare`方法返回一个负数、零或正数，具体取决于它的第一个参数是小于、等于还是大于第二个参数。在实践中你不需要编写这个比较器，因为它实现了整数的自然排序，但它是一个有趣的例子：

```java
// Broken comparator - can you spot the flaw?
Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

这个比较器看起来可以正常使用，也会通过很多测试。比如说，它可以应用于`Collections.sort`来对百万元素的列表进行正确的排序，无论列表中是否包含重复元素均如此。不过，这个比较器是存在问题的。为了能够看到这一点，只需打印出`naturalOrder.compare(new Integer(42), new Integer(42))`的值即可。这两个`Integer`实例表示相同的值（42），因此表达式的值应该是0才对，但结果却是1，这表示第1个Integer值要比第2个大！

那问题出在哪里呢？`naturalOrder`中的第一个测试没问题。计算表达式`i < j`会使得由`i`和`j`所引用的`Integer`实例进行自动拆箱；也就是说，它会提取出其原生值。接着，该表达式会先去检查第一个`int`值是否小于第二个。假如是大于。下一个测试会计算表达式`i==j`，它会对两个对象引用进行同一性比较。如果`i`与`j`引用的是代表相同`int`值的不同`Integer`实例，那么这个比较就会返回`false`，比较器就会错误地返回1，表示第一个`Integer`值大于第二个。**将`==`运算符应用到包装类型上几乎总是错误的。**。

实际上，如果需要一个比较器来描述一个类型的自然顺序，只需调用`Comparator.naturalOrder()`就可以了；如果自己编写比较器，那就应该使用比较器构造方法，或是针对原生类型的`compare`方法（条款14）。也就是说，修复上述比较器问题的方式应该是添加两个局部变量来存储与包装类型`Integer`参数所对应的原生`int`，然后对这些变量执行所有比较。这可以避免错误的身份比较：

```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
	int i = iBoxed, j = jBoxed; // Auto-unboxing
	return i < j ? -1 : (i == j ? 0 : 1);
};
```

接下来，看看如下这段程序：

```java
public class Unbelievable {
	static Integer i;
	public static void main(String[] args) {
		if (i == 42)
			System.out.println("Unbelievable");
	}
}
```

它并不会打印出Unbelievable——不过，其行为却非常奇怪。在计算表达式`i == 42`时，程序会抛出`NullPointerException`。问题在于`i`是个`Integer`而非`int`，就像所有非常量对象引用字段一样，其初始值是`null`。在程序计算表达式`i == 42`时，它会将一个`Integer`与一个`int`进行比较。在几乎所有情况下，**当在一个操作中混合了原生类型与包装类型时，包装类型会进行自动拆箱**。如果一个`null`对象引用进行自动拆箱，那就会抛出`NullPointerException`。正如这段程序所展示的那样，这几乎可以发生在任何地方。修复问题的方法也很简单，只需将`i`声明为`int`而非`Integer`就可以了。

最后，看看来自条款6的这段程序：

```java
// Hideously slow program! Can you spot the object creation?
public static void main(String[] args) {
	Long sum = 0L;
	for (long i = 0; i < Integer.MAX_VALUE; i++) {
		sum += i;
	}
	System.out.println(sum);
}
```

这个程序比它本来的速度慢得多，因为它意外地将一个局部变量`sum`声明为包装类型`Long`，而不是原生类型`long`。程序编译时没有错误或警告，该变量被反复地拆箱和装箱，导致明显的性能下降。

在本条款中讨论三个程序中，问题都是一样的：程序员忽略了原生类型和包装类型之间的区别，并承受了后果。在前两个程序中，后果就是是彻底的失败；在第三个，是严重的性能问题。

那么什么时候应该使用包装类型？它们有几个合理的用法。第一种是作为集合中的元素，如：键和值。你无法将原生类型放到集合中，因此你必须使用包装类型。这是一般情况下的一个特例。在参数化类型和方法（第五章）中，必须使用包装类型作为类型参数，因为Java语言不允许使用原生类型。比如，你不能声明一个`ThreadLocal<int> `类型的变量，你必须使用`  ThreadLocal<Integer>`代替。最后，在进行反射的方法调用时，必须使用包装类型（条款65）。

总之，只要有选择，就应该优先使用原生类型而非包装类型。原生类型更简单也更快。如果你必须使用包装类型，请小心！自动装箱减少了代码冗余，但是没有降低包装类型的危险。当你的程序用`==`操作符对两个包装类型进行比较时，它将做强一致性的比较，这几乎肯定不是你想要的。当你的程序参与了包装类型和原生类型的混合类型计算时，它将进行拆箱，而当你的程序进行拆箱时，它可能会抛出`NullPointerException`。最后，当你的程序将将原生类型装箱后，可能会导致代价高昂且不必要的对象创建。


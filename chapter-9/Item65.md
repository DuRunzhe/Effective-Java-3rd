# 优先选择接口而非反射

核心反射工具`java.lang.reflect`，提供对任意类的编程访问。给定一个`Class`对象，你可以获得`Constructor`、`Method`和`Field`类型的实例，分别表示这个`Class`对象代表的类的构造方法，方法和字段。这些对象提供对类的成员名、字段类型、方法签名等的编程式访问。

而且， `Constructor `,  `Method` 和 `Field` 实例可以让你通过反射来操作他们底层的对应物。你可以通过调用`Constructor`、`Method`和`Field`实例上的方法来构造对应类的实例对象，调用其方法和访问其成员变量。例如，`Method.invoke`允许你在任何类的任何对象上调用任何方法（受通常的安全约束）。反射允许一个类使用另一个类，即使在编译前者时后者并不存在。然而，这种能力是有代价的：

- 你将失去编译期类型检查的好处，包括异常检查。如果一个程序尝试通过反射来调用一个不存在的或者不可访问的方法，那么它会在运行期失败除非你提前采取了特殊的预防措施。
- 通过反射来访问的代码显得笨拙和冗余。这种代码写起来很繁琐，可读性又差。
- 性能受损。通过反射的方法调用法比正常的方法调用要慢许多。由于有许多因素在起作用，所以很难确切地说慢了多少。在我的机器上，通过反射去调用一个无参的方法并返回一个`int`值。比正常调用要慢11倍。


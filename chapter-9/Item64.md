# 通过接口来引用对象

条款51建议应该使用接口而不是类作为参数类型。更一般地说，你应该优先使用接口而不是类来引用对象。**如果存在合适的接口类型，那么应该使用接口类型声明参数、返回值、变量和字段**。只有在使用构造函数创建对象时，才真正需要引用对象的类。具体来说，考虑`LinkedHashSet`的情况，它是`Set`接口的一个实现。好的声明类型的做法是：

```java
// Good - uses interface as type
Set<Son> sonSet = new LinkedHashSet<>();
```

而不是：

```java
// Bad - uses class as type!
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```

**如果你养成了使用接口作为类型的习惯，那么你的程序将会更加灵活**。如果你决定要换一个实现，你所要做的就是更改构造函数中的类名（或使用不同的静态工厂）。例如，第一个声明可以改为：

```java
Set<Son> sonSet = new HashSet<>();
```

并且相关的所有代码都可以继续工作。相关代码并不关心旧的实现类型，因此，它们不知道类型改变了。这里有一个警告：如果起初的实现提供了一些接口规范之外的特殊功能，而且我们的代码也依赖于这些功能，那么新的实现提供相同的功能就显得极其重要。例如，如果围绕第一个声明的代码依赖于`LinkedHashSet`的排序策略，那么将声明中的`LinkedHashSet`替换为`HashSet`是不正确的，因为`HashSet`不保证迭代顺序。

那么，逆为什么想要改变实现类型呢？因为第二个实现提供了比原来的实现更好的性能，或者是因为它提供了更恰当的原来实现没有的功能。例如，假设一个字段包含了一个`HashMap`实例。将`HashMap`该成`EnumMap`会提供更好的性能和与键的自然顺序一致的迭代顺序。但是你只能在键类型为枚举的情况下使用`EnumMap`。将`HashMap`更改为`LinkedHashMap`将提供可预测的迭代顺序，性能与`HashMap`相当，而且对键类型没有任何特殊要求。
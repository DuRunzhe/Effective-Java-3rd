# 使用标记接口来定义类型

标记接口是一个不包含方法声明的接口，它仅仅表示（或“标记”）实现这个接口的类具有某些属性。

比如说，考虑`Serializable`接口（第12章）。通过实现该接口，一个类就表示其实例可以写到`ObjectOutputStream`中（即『序列化』）。

你可能听说过，标记注解（条款39）使得标记接口失去了用武之地，不过这种说法是不对的。相比于标记注解来说，标记接口有两个优势。首先，**标记接口定义了一种类型，该类型由被标记的类的实例所实现；而标记注解是做不到这一点的**。标记接口类型的使用可以让你在编译期就捕获到错误，但是，如果使用标记注解，那这些错误直到运行期才能捕获到。

Java的序列化功能（第6章）使用`Serializable`标记接口来表示某个类型是可以序列化的。`ObjectOutputStream.writeObject`方法会序列化传递给它的对象，它要求参数是可以序列化的。如果该方法的参数类型是`Serializable`的，那么在编译期就可以检测到不恰当的对象序列化（通过类型检查）。编译期错误检测是标记接口的意图与目的，但遗憾的是，`ObjectOutputStream.write` API并未使用`Serializable`接口：其参数类型声明为`Object`，这样序列化一个不可序列化的对象的行为直到运行期才会出现失败。

相比于标记注解来说，标记接口的另外一个好处在于，其目标更为明确。如果某个注解类型声明为了`ElementType.TYPE`，那么它就可以应用到任何类或是接口上。假设你有一个标记，只能应用到某个特定接口的实现上。如果你将它定义成一个标记接口，那么你可以让它去继承它所适用的那个唯一的接口，以保证所有标记的类型也是它所适用的唯一接口的子类型。

可以说，`Set`接口就是这样一个受限制的标记接口。它只能应用于`Collection`子类型，不过除了`Collection`所定义的方法外，它并未添加任何新方法。一般来说，我们不将其看作是标记接口，因为它改变了`Collection`中几个方法的契约，比如说`add`、`equals`与`hashCode`。然而，我们可以很轻松地想出这样一个标记接口，它只能应用于某个特定接口的子类型，但又不会改变接口中任何方法的契约。这种标记接口可以描述整个对象的不变性，或是表示实例可以由其他类的方法进行处理（类似于`Serializable`接口表示实例可以由`ObjectOutputStream`进行处理一样）。

**与标记接口相比，标记注解的主要优势是成为更大的注解设施的一部分**。因此，标记注解支持基于注解的框架的一致性。

那么，什么时候应该使用标记注解，什么时候应该使用标记接口呢？显然，如果标记应用于类或接口之外的任何程序元素上，那么你必须使用注解，因为只有类和接口才能实现或继承一个接口。如果标记只应用于类和接口，那么请扪心自问：“我是否需想要写一个或多个只接受具有此标记的对象的方法？”如果是，那么你应该使用标记接口而不是注解。使用接口作为上面问题中方法的参数类型可能使你获得编译期类型检查的好处。如果你能够说服自己，你永远不会想编写一个只接受带标记对象的方法，那么你最好使用标记注解。此外，如果标记是大量使用注解的框架的一部分，那么标记注解就是明显的选择。

总之，标记接口和标记注解都有它们的用处。如果你想定义一个类型，该类型没有任何新方法跟它关联，可以使用标记接口。如果你想标记处类和接口之外的程序元素，或者将标记放入已经大量使用注解类型的框架中，那么标记符注解是正确的选择。**如果你发现你正在写一个标记注解，它的目标是`ElementType.TYPE`，那么花点时间去想明白它是否真得应该是一个注解类型，或者标记接口是否更合适**。

从某种意义上说，这个条款与条款22相反，条款22是说：“如果不想定义类型，就不要使用接口” 。同样地，这个条款是说，“如果您确实想定义类型，请使用接口。”
# 使用标记接口来定义类型

标记接口是一个不包含方法声明的接口，它仅仅表示（或“标记”）实现这个接口的类具有某些属性。

举个例子，想想`Serializable`接口（12章节）。通过实现这个接口，一个类表明它的实例可以被写入`ObjectOutputStream`（或“被序列化”）。

你可能听说标记注解比标记接口现代化。这个断言是不正确的。标记接口跟标记注解相比有2个优势。第一个也是最重要的，**标记接口可以定义了一个类型，该类型由被标记的类的实例实现；而标记注解不行**。标记接口类型的存在允许你在编译时捕获错误，如果使用标记注解，那这些错误直到运行时才能捕获到。

Java的序列化工具（第6章）使用`Serializable`标记符接口来表示一个类型是可序列化的。`ObjectOutputStream.writeObject`方法可以序列化传递给它的对象，但要求它的参数是可序列化的。如果这个方法参数是`Serializable `类型的，那么在尝试序列化一个不恰当的对象时，在编译期就会被检测出来（通过类型检查）。编译期错误检测试标记接口的意图，但不幸的是，`ObjectOutputStream.write` API没有利用`Serializable`接口：它的参数声明为`Object`类型，因此在尝试序列化一个不可序列化的对象时，到运行时才会发生失败。

与标记注解相比，标记接口的另一个优点是可以更精确地定位它们。如果一个注解类型，使用`ElementType.TYPE`来声明了，表示它可以作用于任何类和接口上。假设你有一个只适用于特定接口实现的标记。如果你将它定义成一个标记接口，那么你可以让它去继承它所适用的那个唯一的接口，以保证所有标记的类型也是它所适用的唯一接口的子类型。

可以说，`Set`接口就是这样一个受限制的标记接口。它只适用于`Collection`的子类型，但是除了`Collection`定义的方法之外，它没有添加任何方法。然而它通常不被认为是一个标记接口，因为它细化了几个`Collection`方法的契约，包括`add`、`equals`和`hashCode`。但是很容易想象一个标记接口只适用于某些特定接口的子类型，而不细化接口的任何方法的契约。这样的标记接口可以描述整个对象的某些不变量，或者表明实例有资格被其他类的方法进行处理。（比如，`Serializable`接口表示实例有资格被`ObjectOutputStream`进行处理）

**与标记接口相比，标记注解的主要优势是成为更大的注解设施的一部分**。因此，标记注解支持基于注解的框架的一致性。

那么，什么时候应该使用标记注解，什么时候应该使用标记接口呢？显然，如果标记应用于类或接口之外的任何程序元素上，那么你必须使用注解，因为只有类和接口才能实现或继承一个接口。如果标记只应用于类和接口，那么请扪心自问：“我是否需想要写一个或多个只接受具有此标记的对象的方法？”如果是，那么你应该使用标记接口而不是注解。使用接口作为上面问题中方法的参数类型可能使你获得编译期类型检查的好处。如果你能够说服自己，你永远不会想编写一个只接受带标记对象的方法，那么你最好使用标记注解。此外，如果标记是大量使用注解的框架的一部分，那么标记注解就是明显的选择。

总之，标记接口和标记注解都有它们的用处。如果你想定义一个类型，该类型没有任何新方法跟它关联，可以使用标记接口。如果你想标记处类和接口之外的程序元素，或者将标记放入已经大量使用注解类型的框架中，那么标记符注解是正确的选择。**如果你发现你正在写一个标记注解，它的目标是`ElementType.TYPE`，那么花点时间去想明白它是否真得应该是一个注解类型，或者标记接口是否更合适**。

从某种意义上说，这个条款与条款22相反，条款22是说：“如果不想定义类型，就不要使用接口” 。同样地，这个条款是说，“如果您确实想定义类型，请使用接口。”
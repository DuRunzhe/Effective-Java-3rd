# 谨慎设计方法签名

本条款涉及到诸多API设计相关的内容，我们将这些内容放到一起来讲解。这有助于你编写出更易于学习、使用且不易出错的API。

**谨慎选择方法名**。名字应该总是遵循标准的命名约定（条款68）。你你的首要目标应当是选择易于理解且与相同包下其他名字一致的名字。第二个目标则是选择与大众普遍认可的名字（如果有的话）相一致的名字。请避免使用过长的方法名。如果存疑，请查阅Java库APIs看一看。虽然有很多不一致的地方（考虑到这些库的大小与规模，这是不可避免的），不过还是有很多一致的地方。

**不要热衷于提供便捷方法。**。每个方法都应该『做好自己的分内之事』。过多的方法会使得类变得难以学习、使用、文档化、测试与维护。这一点对于接口来说更是如此，接口中过多的方法会让接口实现者和用户苦不堪言。对于类或是接口所支持的每个动作来说，请提供一个完整功能的方法。只有在方法经常被使用的情况下才考虑提供『简洁的』方法。**如果存疑，那就不要提供**。

**避免过长的参数列表**。至多提供4个参数或是更少一些。大多数程序员记不住太长的参数列表。如果很多方法都超过了这个限制，那就需要不停地查阅文档才能使用好API。虽然现代IDE可以在这一点上帮助到你，不过最好还是使用短一些的参数列表。同类型过长的参数列表危害更大。用户不仅记不住参数的顺序，而且当不小心调换了参数顺序时，程序依旧可以编译通过且运行起来。只不过程序的运行结果与编写者的意图不一样。

有3种做法可以缩短过长的参数列表。第1种是将一个方法分解为多个方法，分解后的每个方法只需要部分参数。如果不小心，那就会导致过多的方法，不过可以通过增加正交性来减少方法数量。比如说，考虑`java.util.List`接口。它并没有提供在子列表中寻找元素的第一个或是最后一个索引的方法，这两个方法都需要3个参数。相反，它提供了一个`subList`方法，该方法接收两个参数，并且返回一个子列表的视图。该方法可以与`indexOf`或是`lastIndexOf`方法组合起来，这两个方法都只有单个参数，这样就可以实现所需的功能了。此外，`subList`方法可以与任何对`List`实例进行操作的方法结合，从而完成对子列表的任意计算。这样，得到的API就拥有非常高的动力比了。

缩短长参数列表的第二种技术是创建一个辅助类来持有参数组。通常，这些辅助类是静态成员类（条款24）。如果代表不同实体的参数列表频繁出现，则建议使用此技术。举个例子，假设你正在写一个代表卡片游戏的类，并且你发现你自己不断地传递分别代表了卡片排行和它的套件的2个参数的序列。如果你增加一个辅助类代表卡片并且用这一个辅助类把每个有该参数序列的地方替换掉，那么你的API和你的类内部可能会得好处。

第三种技术结合了前两个并将构建器模式（条款2）从对象构造适配成方法调用。如果你有一个方法有很多参数，尤其当其中一些参数可选的时候，好的做法是：定义一个代表了所有参数的对象并为这个对象提供多个“setter”方法调用，每一个“setter”方法设置了一个参数或者小的相关组。一旦期望的参数设置好，客户端调用该对象的“execute”方法，该方法会对参数做一些最后的正确性校验，并且执行实际的计算。

**对于参数类型，优先选择接口而不是类**（条款64）。如果有合适的接口来定义参数，那么使用它来支持该接口的实现类。比如，我们不应该写一个接受`HashMap`类型的入参的方法，而应该用`Map`代替。这样做，你可以传`HashMap`、`TreeMap`、`ConcurrentHashMap`、`TreeMap`的子映射或任何尚未编写的映射实现。通过使用类而不是接口，你可以将客户端限制在特定的实现中，如果输入数据碰巧以某种其他形式存在，则会强制执行不必要的、可能代价很高的复制操作。

优先使用2个元素的枚举类型，而不是布尔参数。除非布尔值的含义对于方法名字来说是清晰的。枚举使代码更容易读和写。而且，以后添加更多的选项也很容易。例如，你可能有一个温度计类型和一个接受这个类型枚举的静态工厂：

```
public enum TemperatureScale { FAHRENHEIT, CELSIUS }
```

` Thermometer.newInstance(TemperatureScale.CELSIUS) `不仅比`Thermometer.newInstance(true) `更有意义，而且在以后的版本中，你可以添加`KELVIN `到`TemperatureScale `中，而不需要在`Thermometer `里添加新的静态工厂方法。此外，你还可以将温度刻度的依赖重构成依托枚举常量的方法（条款34）。比如，每一个刻度常量都可以有一个方法，它接受一个双精度值并且将它转成摄氏度。
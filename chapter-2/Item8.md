## 避免使用终结方法和清除方法

**终结方法（Finalizers）是不可预知的，经常是危险的而且通常是没有必要地**。它们的使用会导致不稳定的行为、糟糕的性能和可移植性问题。终结方法有一些有效的用途，我们将在后面的条款中介绍，但是作为一个规则，你应该避免他们。在Java 9中，终结方法已经被弃用，但是Java库仍然在使用它们。Java 9中，替代终结方法的是清除方法（cleaner）。**清除方法比终结方法危险小，但仍然不可预测、效率慢，而且通常没有必要**。 

c++程序员被告诫不要将Java的终结方法或清除方法当作是跟c++的析构函数一样的类似物 。在c++中，析构函数是回收与对象相关的资源的常规方法，是构造函数的必要对应。 在Java中，当一个对象变得不可到达时，垃圾收集器将回收与该对象关联的存储空间，而且程不需要程序员付出特别的努力。 c++析构函数也可以用于回收其他非内存资源。在Java中，`try -with-resources`或`try - finally`代码块就是用于此目的(第9条)。

终结方法和清除方法的一个缺点是不能保证它们会被迅速执行[JLS, 12.6]。 从对象变得无法访问的时候到其终结方法或清除方法运行的时间之间可能花费任意长度的时间。这意味着你不应该在终结方法或清除方法中做任何有时间限制的事情。例如，依赖于终结方法或清除方法来关闭文件是一个严重的错误，因为打开的文件描述符是有限的资源。如果由于系统在运行终结方法或清除方法时的延迟而导致许多文件处于打开状态，则程序可能会因为无法再打开文件而失败。

终结方法或清除方法执行的速度主要依赖垃圾收集算法的功能，而这个功能在不同的实现中差别很大。所以，依赖于终结方法或清除方法执行的快速性的程序的行为同样会有差异。因此，同样一个程序在你测试的JVM中完美运行，然后却在你最重要的客户上的机器上不幸地失败了，这种情况是完全有可能发生的。

缓慢的终结方法不只是一个理论上的难题。为类提供终结方法可能会随意地延迟自己的实例的回收。一位同事调试了一个长期运行的GUI应用程序，该应用程序因`OutOfMemoryError`而奇怪地崩溃过。分析显示，在应用程序崩溃的时候，它的终结方法的队列中有数千个图形对象等待被终结并回收。不幸的是，终结方法的线程以一个比其他的应用线程要更低的优先级运行着，因此对象没有在他们可以被终结的时候被终结掉。Java语言规范没有明确说明哪个线程将执行终结方法，因此除了避免使用终结方法之外，没有其他更方便的方法来防止这类问题。在这方面，清除方法比终结方法好一点，因为类作者可以控制自己的清除方法，但是清除方法仍然在后台运行，在垃圾收集器的控制下，所以不能保证及时清理。 

规范不仅不保证终结方法或清除方法能够迅速运行; 也根本不保证方法就会运行。而且，当一些对象变得不再可达到的时候，程序完全有可能没有在这些对象上运行上面提到的方法就终止了。因此，您不应该依赖终结方法或清除方法来更新持久状态。 例如，依赖终结方法或清除方法来释放共享资源(如数据库)上的持久锁是使整个分布式系统陷入严重停顿的好方法。 

不要被`System.gc`和`System.runFinalization`方法所诱惑。它们可能会增加终结方法或清除方法被执行的几率，但他们并不能保证一定如此。两种方法曾提出保证：`System.runFinalizersOnExit`和`Runtime.runFinalizersOnExit`是一对邪恶的双胞胎。这些方法有致命的缺陷，并且已经被弃用了几十年[ThreadStop]。

终结方法的另一个问题是，在终结的过程中抛出未捕获的异常会被忽略，该对象的终结方法的执行会被终止[JLS, 12.6]。未捕获的异常可以使其他对象处于损坏状态。如果另一个线程试图使用这样一个已损坏的对象，则可能导致任意的不确定性行为。正常情况下，未捕获的异常将终止线程并打印堆栈跟踪，但如果它发生在finalizer中，则不会打印警告。清除方法没有这个问题，因为使用清除方法的库可以控制它的线程。

**使用终结方法和清除方法会有严重的性能损失**。在我的机器上，创建一个简单的 `AutoCloseable`对象的时间,使用`try-with-resources`关闭它，并让垃圾收集器回收它的时间大约是12纳秒 。使用终结方法可以将时间增加到550纳秒。换句话说，使用终结方法创建和销毁对象的速度要慢50倍。这主要是因为终结方法抑制了有效的垃圾收集。如果你使用它们来清理类的所有实例(在我的机器上，每个实例大约500纳秒)，那么清除方法的速度可以与终结方法相比，但是如果你仅将它们作为一个安全网来使用，那么清除方法的速度要快得多，如下所述。 在这种情况下，创建、清洗和销毁一个对象在我的机器上大约需要66纳秒，这意味着如果你不使用它，你要为一个安全网支付五倍(而不是五十倍)的保险费。

终结方法有一个严重的安全问题：它们打开你的类，受到终结方法的攻击。 终结方法攻击的思路很简单：如果从构造函数或它的序列化等价物(`readObject`和`readResolve` 方法，第12章)抛出异常，那么恶意子类的终结方法可以运行在部分构造的对象上，其实该对象应该“死在藤蔓上”。终结方法可以在静态字段中记录一个对象的引用，用来阻止它被垃圾收集器回收。 一旦记录了这种有缺陷的对象，那么调用这个本不应该存在这个地方的对象上的任意方法都是一件简单的事情。**从构造函数中抛出异常应该足以阻止对象的产生;在终结方法下，它不是的**。 这种攻击可能会产生可怕的后果。 Final类是不会受到终结方法的攻击的，因为没有人可以编写 Final类的恶意子类。为了保护非final类免于终结方法的攻击，我们可以写一个不执行任何操作的final finalize方法。

那么，你应该做些什么呢，来代替给对象封装了需要关闭的资源(如文件或线程)的类编写终结方法和清除方法？只要让你的类实现`AutoCloseable`，并要求它的客户端在不再需要它时，在每个实例上调用close方法，通常使用`try -with-resources`来确保即使在遇到异常时也要终止(第9项)。值得一提的一个细节是实例必须跟踪它是否已被关闭：`close`法必须在对象不再有效的字段中记录，如果它们在该对象已经被关闭后被调用，那么他方法必须检查此字段并抛出`IllegalStateException` 。

那么，如果终结方法和清除方法真的有用途，那么他们的好处是什么呢？他们可能有2个合理的用途。一个是作为网络安全使用，以防资源的拥有者忘记调用它的`close`方法。然后这里并不保证清除方法的或终结方法会立即运行(或者根本不会) ，如果客户端没有这样做，那么延迟资源的释放，比什么也不做要好。
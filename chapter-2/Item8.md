## 避免使用终结器与清理器

**终结器是不可预测的、常常会很危险，而且通常没必要。使用终结器会导致奇怪的行为、孱弱的性能以及可移植性问题**。终结器有一些有效的用途，我们将在后面的条款中介绍，但是作为一个规则，你应该避免他们。在Java 9中，终结器已经被弃用，但是Java库仍然在使用它们。Java 9中，替代终结器的是清除器（cleaner）。**清除器比终结器危险小，但仍然不可预测、效率慢，而且通常没有必要**。 

C++程序员们不要将Java中的终结器或是清理器当作是C++中的析构函数。在C++中，析构函数是回收与对象所关联的资源的常规方式，它是与构造函数必要的一个对应之物。 在Java中，当与对象所关联的存储变得不可达时，垃圾收集器就会将其回收，不需要程序员做任何额外的事情。 c++析构函数也可以用于回收其他非内存资源。在Java中，`try-with-resources`或`try-finally`代码块就是用于此目的(第9条)。

终结器与清理器的一个缺点在于，没有人可以保证他们会立刻执行[JLS, 12.6]。在对象变得不可及与终结器或是清理器开始运行之间可能会间隔任意长的时间。这意味着你永远不要在终结器或是清理器中做任何时间关键的事情。例如，依赖于终结方法或清除方法来关闭文件就是一个严重的错误，因为打开的文件描述符是有限的资源。如果由于系统运行终结器或是清理器产生了延迟而导致很多文件处于打开的状态，那么程序就有可能失败，因为它无法再打开文件了。

到底哪个终结器和清理器会执行主要是由垃圾回收算法来决定的，而算法在不同的实现间存在着较大的差别 。依赖于终结器或是清理器的立刻执行的程序行为也存在着较大的差别。因此，同样一个程序在你测试的JVM中完美运行，然后却在你最重要的客户上的机器上不幸地失败了，这种情况是完全有可能发生的。

终结器不会立刻执行并不仅仅是个理论上的问题 。为类提供终结方法可能会随意地延迟自己的实例的回收。一位同事调试了一个长期运行的GUI应用程序，该应用程序因`OutOfMemoryError`而奇怪地崩溃过。分析显示，在应用程序崩溃的时候，它的终结方法的队列中有数千个图形对象等待被终结并回收。遗憾的是，终结器运行所在的线程要比另一个应用线程的优先级低，这样对象被终止的速度远远跟不上其进入到终止状态的速度。Java语言规范没有明确说明哪个线程将执行终结器，因此除了避免使用终结器之外，没有其他更方便的方法来防止这类问题。这个问题上，清洁器在这方面要比终结器好一些，因为类的创建者可以控制自己的清洁器线程，不过，清洁器依然运行在后台，在垃圾收集器的控制之下，因此对于立刻清洁这个问题也没有提供任何保证。

规范不仅没有提供终结器或是清理器会立刻运行的保证，也没有对其一定会运行提供任何保证。完全有可能出现这样的情况，当程序终止时，它并没有对早就处于不可达的对象运行其终结器和清理器。因此，你永远都不应该依赖于终结器或是清理器来更新持久化状态。比如说，依赖于终结器或是清理器来释放如数据库等共享资源上的持久化锁可能会导致整个分布式系统陷入瘫痪状态。

不要被`System.gc`和`System.runFinalization`方法所诱惑。它们可能会增加终结方法或清除方法被执行的几率，但他们并不能保证一定如此。曾经有两个方法做过这个保证：`System.runFinalizersOnExit`及其搭档`Runtime.runFinalizersOnExit`。这两个方法存在严重的问题，早就已经不建议使用了[ThreadStop]。

终结器的另一个问题是在执行终结时，未捕获的异常会被忽略掉，这时对象的终结会被终止[JLS, 12.6]。未捕获的异常会导致其他对象的状态被破坏掉。如果另一个线程试图使用这样一个已损坏的对象，则可能导致任意的不确定性行为。正常情况下，未捕获的异常会终止线程并打印堆栈信息，但如果在终结器中就不会这样——它甚至不会打印出任何警告信息。清理器不存在这个问题，因为使用了清理器的库会自己控制其线程。。

**使用终结方法和清除方法会有严重的性能损失**。在我的机器上，创建一个简单的`AutoCloseable`对象，使用`try-with-resources`关闭它，然后让垃圾收集器对其进行回收，大约需要花费12ns。使用终结器可以将时间增加到550纳秒。换句话说，使用终结器创建和销毁对象的速度要慢50倍。这主要是因为终结器阻碍了高效的垃圾回收。如果使用清理器来清除类的所有实例（在我的机器上每个实例大约需要花费500ns），它在速度上与终结器大致相同；不过，如果只是将清理器作为一个安全网（后续将会介绍），那么其速度将会快很多。如下所述。在这些情况下，我的机器上创建、清理与销毁一个对象所花费的时间大约需要66ns，这意味着你为安全网的使用需要付出5倍因子（不是50倍）的代价。

终结方法有一个严重的安全问题：他们会使你的类遭遇到终结器攻击。终结器攻击背后的想法非常简单：如果异常是从构造方法或是序列化方法`readObject`与`readResolve`中抛出的（第12章），那么恶意的子类终结器就会运行在部分构建完毕的对象上，而这个对象本应该『中途夭折的』。这个终结器会将对对象的引用记录在一个静态字段中，防止其被垃圾回收掉。一旦将这个不完整的对象记录下来后，我们就可以轻松调用这个对象上的任意方法，而这个对象原本是不应该存在的。**从构造方法中抛出异常足以禁止对象的创建；但在使用终结器的情况下，却并非如此。**。 这种攻击还会产生非常严重的后果。终态类不受终结器攻击的影响，因为没人可以创建终态类的恶意子类。若想保护非终态类免受终结器攻击，请编写一个什么都不做的final的finalize方法。。

那么，对于封装了需要终止的资源（如文件或是线程）的对象来说，如果不为类编写终结器或是清理器，那该怎么办呢？只需让类实现`AutoCloseable`即可，并让其客户端在不需要其实例时调用其`close`方法，通常我们会使用`try-with-resources`来确保终止，即便在异常的情况下亦如此（条款9）。值得提及的一个细节是，实例必须要追踪其是否已经关闭了：`close`方法必须要在一个字段中记录下对象已经不再有效了，其他方法则必须要检查该字段，如果当对象已经关闭后还调用这些方法，那就需要抛出`IllegalStateException`异常。

那么，如果终结方法和清除方法真的有用途，那么他们的好处是什么呢？他们可能有2个合理的用途。一个是作为网络安全使用，以防资源的拥有者忘记调用它的`close`方法。然后这里并不保证清除方法的或终结方法会立即运行(或者根本不会) ，如果客户端没有这样做，那么延迟资源的释放，比什么也不做要好。

清除方法第二个合理的用法是将普通对象和本地的同等对象（`native peers`）关联起来。普通对象通过本地方法（native method）委托给本地对象，就是本地同等对象。因为本地同等对象不是普通对象，所以垃圾收集器无法识别它，并且当它对应的Java对象被回收时，它自己也不会被回收。如果它的性能是可接受的并且本地同等对象没有持有关键资源，那么对上述的任务来说，清除方法或终结方法可能是一个不错的媒介。如果性能不可接受或者本地同等对象拥有必须立即回收的资源，那么如前所述，该类应具有`close`方法。

清除方法使用起来有点棘手。下面是一个简单的`Room`类，说明了清除方法的作用。我们假设房间必须在回收之前进行清洁。Room类实现`AutoCloseable`接口，它使用清洁器自动清理安全网络的事实仅仅是一个细节实现。与终结方法不同，清除方法不会污染类的公共API：

```java
// An autocloseable class using a cleaner as a safety net
public class Room implements AutoCloseable {
    
	private static final Cleaner cleaner = Cleaner.create();
    
    // Resource that requires cleaning. Must not refer to Room!
    private static class State implements Runnable {
        int numJunkPiles; // Number of junk piles in this room
        
        State(int numJunkPiles) {
            this.numJunkPiles = numJunkPiles;
        }
        
        // Invoked by close method or cleaner
        @Override 
        public void run() {
            System.out.println("Cleaning room");
            numJunkPiles = 0;
        }
	}
    
    // The state of this room, shared with our cleanable
    private final State state;
    
    // Our cleanable. Cleans the room when it’s eligible for gc
    private final Cleaner.Cleanable cleanable;
    
    public Room(int numJunkPiles) {
        state = new State(numJunkPiles);
        cleanable = cleaner.register(this, state);
    }
    
    @Override 
    public void close() {
        cleanable.clean();
    }
}
```

静态内部类`State`持有清洁器清洁房间所需的资源。在这个例子中，资源就是字段`numJunkPiles`，表示房间中的混乱程度。更现实的是，它可能是一个包含指向本地同等对象的指针的终态的长整型。State实现了`Runnable`，它的`run`方法最多被调用一次，当我们在`Room`构造函数中使用我们的清理器注册`State`实例时，然后我们得到了`Cleanable`。对`run`方法的调用将由以下两种方法之一触发：通常是通过调用`Room`的`close`方法调用`Cleanable`的`clean`方法来触发它。如果客户端无法在`Room`实例符合垃圾收集条件时调用`close`方法，则清理器将（希望）调用`State`的`run`方法。

`state`实例不持有对它的`Room`实例的引用，这一点很重要。如果它持有引用，那么它会创造一个死循环，阻止`Room`实例被垃圾收集器回收（以及自动清理）。因此，`State`必须是一个静态内部类，因为非静态内部类包含对其外部类实例的引用(项目24)。同样不建议使用`lambda`，因为它们可以很容易地捕获对外部类对象的引用。 

就像我们之前说的，`Room`的清洁剂只是用作安全网。如果客户端用`try -with-resource`块来包围所有`Room`实例，则永远不需要自动清理。这位表现良好的客户展示了这种行为：

```java
public class Adult {
    public static void main(String[] args) {
        try (Room myRoom = new Room(7)) {
        	System.out.println("Goodbye");
        }
    }
}
```

如你所期盼的，运行`Adult`程序会打印`Goodbye`，接着就是清理`Room`。但是，行为粗鲁的程序是什么样子的呢？它从不清洁他的房间？

```java
public class Teenager {
    public static void main(String[] args) {
    	new Room(99);
    	System.out.println("Peace out");
    }
}
```

你可能期望在清洁完房间后，让他打印出“Peace out”。但是在我的机器上，他永远不会打印“Cleaning room”。程序仅仅就是退出了。这就是我们之前提到的不可预测性。这个`Cleaner`规范说道，“在系统退出期间，清除的行为是特定于实现的，但它保证相关的清除行为是否能被调用。”虽然规范没有说明，但是对于普通程序退出来说是一样的。在我的机器上，往`Teenager`类的`main`方法里一行` System.gc()`，能让程序在退出前打印“Cleaning room”，但是不保证在你的机器上就能看到相同的结果。

总之，除了作为安全网或终止非关键的本机资源之外，不要使用清除方法，也不要使用Java 9之前的版本，终结方法。 即使这样，也要注意不确定性和性能后果。
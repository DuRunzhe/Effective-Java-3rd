## 避免使用终结方法和清除方法

**终结方法（Finalizers）是不可预知的，经常是危险的而且通常是没有必要地**。它们的使用会导致不稳定的行为、糟糕的性能和可移植性问题。终结方法有一些有效的用途，我们将在后面的条款中介绍，但是作为一个规则，你应该避免他们。在Java 9中，终结方法已经被弃用，但是Java库仍然在使用它们。Java 9中，替代终结方法的是清除方法（cleaner）。**清除方法比终结方法危险小，但仍然不可预测、效率慢，而且通常没有必要**。 

c++程序员被告诫不要将Java的终结方法或清除方法当作是跟c++的析构函数一样的类似物 。在c++中，析构函数是回收与对象相关的资源的常规方法，是构造函数的必要对应。 在Java中，当一个对象变得不可到达时，垃圾收集器将回收与该对象关联的存储空间，而且程不需要程序员付出特别的努力。 c++析构函数也可以用于回收其他非内存资源。在Java中，`try -with-resources`或`try - finally`代码块就是用于此目的(第9条)。

终结方法和清除方法的一个缺点是不能保证它们会被迅速执行[JLS, 12.6]。 从对象变得无法访问的时候到其终结方法或清除方法运行的时间之间可能花费任意长度的时间。这意味着你不应该在终结方法或清除方法中做任何有时间限制的事情。例如，依赖于终结方法或清除方法来关闭文件是一个严重的错误，因为打开的文件描述符是有限的资源。如果由于系统在运行终结方法或清除方法时的延迟而导致许多文件处于打开状态，则程序可能会因为无法再打开文件而失败。

终结方法或清除方法执行的速度主要依赖垃圾收集算法的功能，而这个功能在不同的实现中差别很大。所以，依赖于终结方法或清除方法执行的快速性的程序的行为同样会有差异。因此，同样一个程序在你测试的JVM中完美运行，然后却在你最重要的客户上的机器上不幸地失败了，这种情况是完全有可能发生的。

缓慢的终结方法不只是一个理论上的难题。为类提供终结方法可能会随意地延迟自己的实例的回收。一位同事调试了一个长期运行的GUI应用程序，该应用程序因`OutOfMemoryError`而奇怪地崩溃过。分析显示，在应用程序崩溃的时候，它的终结方法的队列中有数千个图形对象等待被终结并回收。不幸的是，终结方法的线程以一个比其他的应用线程要更低的优先级运行着，因此对象没有在他们可以被终结的时候被终结掉。Java语言规范没有明确说明哪个线程将执行终结方法，因此除了避免使用终结方法之外，没有其他更方便的方法来防止这类问题。在这方面，清除方法比终结方法好一点，因为类作者可以控制自己的清除方法，但是清除方法仍然在后台运行，在垃圾收集器的控制下，所以不能保证及时清理。 

规范不仅不保证终结方法或清除方法能够迅速运行; 也根本不保证方法就会运行。而且，当一些对象变得不再可达到的时候，程序完全有可能没有在这些对象上运行上面提到的方法就终止了。因此，您不应该依赖终结方法或清除方法来更新持久状态。 例如，依赖终结方法或清除方法来释放共享资源(如数据库)上的持久锁是使整个分布式系统陷入严重停顿的好方法。 

不要被`System.gc`和`System.runFinalization`方法所诱惑。它们可能会增加终结方法或清除方法被执行的几率，但他们并不能保证一定如此。两种方法曾提出保证：`System.runFinalizersOnExit`和`Runtime.runFinalizersOnExit`是一对邪恶的双胞胎。这些方法有致命的缺陷，并且已经被弃用了几十年[ThreadStop]。

终结方法的另一个问题是，在终结的过程中抛出未捕获的异常会被忽略，该对象的终结方法的执行会被终止[JLS, 12.6]。未捕获的异常可以使其他对象处于损坏状态。如果另一个线程试图使用这样一个已损坏的对象，则可能导致任意的不确定性行为。正常情况下，未捕获的异常将终止线程并打印堆栈跟踪，但如果它发生在finalizer中，则不会打印警告。清除方法没有这个问题，因为使用清除方法的库可以控制它的线程。

**使用终结方法和清除方法会有严重的性能损失**。在我的机器上，创建一个简单的 `AutoCloseable`对象的时间,使用`try-with-resources`关闭它，并让垃圾收集器回收它的时间大约是12纳秒 。使用终结方法可以将时间增加到550纳秒。换句话说，使用终结方法创建和销毁对象的速度要慢50倍。这主要是因为终结方法抑制了有效的垃圾收集。如果你使用它们来清理类的所有实例(在我的机器上，每个实例大约500纳秒)，那么清除方法的速度可以与终结方法相比，但是如果你仅将它们作为一个安全网来使用，那么清除方法的速度要快得多，如下所述。 在这种情况下，创建、清洗和销毁一个对象在我的机器上大约需要66纳秒，这意味着如果你不使用它，你要为一个安全网支付五倍(而不是五十倍)的保险费。

终结方法有一个严重的安全问题：它们打开你的类，受到终结方法的攻击。 终结方法攻击的思路很简单：如果从构造函数或它的序列化等价物(`readObject`和`readResolve` 方法，第12章)抛出异常，那么恶意子类的终结方法可以运行在部分构造的对象上，其实该对象应该“死在藤蔓上”。终结方法可以在静态字段中记录一个对象的引用，用来阻止它被垃圾收集器回收。 一旦记录了这种有缺陷的对象，那么调用这个本不应该存在这个地方的对象上的任意方法都是一件简单的事情。**从构造函数中抛出异常应该足以阻止对象的产生;在终结方法下，它不是的**。 这种攻击可能会产生可怕的后果。 Final类是不会受到终结方法的攻击的，因为没有人可以编写 Final类的恶意子类。为了保护非final类免于终结方法的攻击，我们可以写一个不执行任何操作的final finalize方法。

那么，你应该做些什么呢，来代替给对象封装了需要关闭的资源(如文件或线程)的类编写终结方法和清除方法？只要让你的类实现`AutoCloseable`，并要求它的客户端在不再需要它时，在每个实例上调用close方法，通常使用`try-with-resources`来确保即使在遇到异常时也要终止(第9项)。值得一提的一个细节是实例必须跟踪它是否已被关闭：`close`法必须在对象不再有效的字段中记录，如果它们在该对象已经被关闭后被调用，那么他方法必须检查此字段并抛出`IllegalStateException` 。

那么，如果终结方法和清除方法真的有用途，那么他们的好处是什么呢？他们可能有2个合理的用途。一个是作为网络安全使用，以防资源的拥有者忘记调用它的`close`方法。然后这里并不保证清除方法的或终结方法会立即运行(或者根本不会) ，如果客户端没有这样做，那么延迟资源的释放，比什么也不做要好。

清除方法第二个合理的用法是将普通对象和本地的同等对象（`native peers`）关联起来。普通对象通过本地方法（native method）委托给本地对象，就是本地同等对象。因为本地同等对象不是普通对象，所以垃圾收集器无法识别它，并且当它对应的Java对象被回收时，它自己也不会被回收。如果它的性能是可接受的并且本地同等对象没有持有关键资源，那么对上述的任务来说，清除方法或终结方法可能是一个不错的媒介。如果性能不可接受或者本地同等对象拥有必须立即回收的资源，那么如前所述，该类应具有`close`方法。

清除方法使用起来有点棘手。下面是一个简单的`Room`类，说明了清除方法的作用。我们假设房间必须在回收之前进行清洁。Room类实现`AutoCloseable`接口，它使用清洁器自动清理安全网络的事实仅仅是一个细节实现。与终结方法不同，清除方法不会污染类的公共API：

```java
// An autocloseable class using a cleaner as a safety net
public class Room implements AutoCloseable {
    
	private static final Cleaner cleaner = Cleaner.create();
    
    // Resource that requires cleaning. Must not refer to Room!
    private static class State implements Runnable {
        int numJunkPiles; // Number of junk piles in this room
        
        State(int numJunkPiles) {
            this.numJunkPiles = numJunkPiles;
        }
        
        // Invoked by close method or cleaner
        @Override 
        public void run() {
            System.out.println("Cleaning room");
            numJunkPiles = 0;
        }
	}
    
    // The state of this room, shared with our cleanable
    private final State state;
    
    // Our cleanable. Cleans the room when it’s eligible for gc
    private final Cleaner.Cleanable cleanable;
    
    public Room(int numJunkPiles) {
        state = new State(numJunkPiles);
        cleanable = cleaner.register(this, state);
    }
    
    @Override 
    public void close() {
        cleanable.clean();
    }
}
```

静态内部类`State`持有清洁器清洁房间所需的资源。在这个例子中，资源就是字段`numJunkPiles`，表示房间中的混乱程度。更现实的是，它可能是一个包含指向本地同等对象的指针的终态的长整型。State实现了`Runnable`，它的`run`方法最多被调用一次，当我们在`Room`构造函数中使用我们的清理器注册`State`实例时，然后我们得到了`Cleanable`。对`run`方法的调用将由以下两种方法之一触发：通常是通过调用`Room`的`close`方法调用`Cleanable`的`clean`方法来触发它。如果客户端无法在`Room`实例符合垃圾收集条件时调用`close`方法，则清理器将（希望）调用`State`的`run`方法。

`state`实例不持有对它的`Room`实例的引用，这一点很重要。如果它持有引用，那么它会创造一个死循环，阻止`Room`实例被垃圾收集器回收（以及自动清理）。因此，`State`必须是一个静态内部类，因为非静态内部类包含对其外部类实例的引用(项目24)。同样不建议使用`lambda`，因为它们可以很容易地捕获对外部类对象的引用。 

就像我们之前说的，`Room`的清洁剂只是用作安全网。如果客户端用`try -with-resource`块来包围所有`Room`实例，则永远不需要自动清理。这位表现良好的客户展示了这种行为：

```java
public class Adult {
    public static void main(String[] args) {
        try (Room myRoom = new Room(7)) {
        	System.out.println("Goodbye");
        }
    }
}
```

如你所期盼的，运行`Adult`程序会打印`Goodbye`，接着就是清理`Room`。但是，行为粗鲁的程序是什么样子的呢？它从不清洁他的房间？

```java
public class Teenager {
    public static void main(String[] args) {
    	new Room(99);
    	System.out.println("Peace out");
    }
}
```

你可能期望在清洁完房间后，让他打印出“Peace out”。但是在我的机器上，他永远不会打印“Cleaning room”。程序仅仅就是退出了。这就是我们之前提到的不可预测性。这个`Cleaner`规范说道，“在系统退出期间，清除的行为是特定于实现的，但它保证相关的清除行为是否能被调用。”虽然规范没有说明，但是对于普通程序退出来说是一样的。在我的机器上，往`Teenager`类的`main`方法里一行` System.gc()`，能让程序在退出前打印“Cleaning room”，但是不保证在你的机器上就能看到相同的结果。

总之，除了作为安全网或终止非关键的本机资源之外，不要使用清除方法，也不要使用Java 9之前的版本，终结方法。 即使这样，也要注意不确定性和性能后果。
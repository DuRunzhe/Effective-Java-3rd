## 避免使用终结方法和清除方法

**终结方法（Finalizers）是不可预知的，经常是危险的而且通常是没有必要地**。它们的使用会导致不稳定的行为、糟糕的性能和可移植性问题。终结方法有一些有效的用途，我们将在后面的条款中介绍，但是作为一个规则，你应该避免他们。在Java 9中，终结方法已经被弃用，但是Java库仍然在使用它们。Java 9中，替代终结方法的是清除方法（cleaner）。**清除方法比终结方法危险小，但仍然不可预测、效率慢，而且通常没有必要**。 

c++程序员被告诫不要将Java的终结方法或清除方法当作是跟c++的析构函数一样的类似物 。在c++中，析构函数是回收与对象相关的资源的常规方法，是构造函数的必要对应。 在Java中，当一个对象变得不可到达时，垃圾收集器将回收与该对象关联的存储空间，而且程不需要程序员付出特别的努力。 c++析构函数也可以用于回收其他非内存资源。在Java中，`try -with-resources`或`try - finally`代码块就是用于此目的(第9条)。

终结方法和清除方法的一个缺点是不能保证它们会被迅速执行[JLS, 12.6]。 从对象变得无法访问的时候到其终结方法或清除方法运行的时间之间可能花费任意长度的时间。这意味着你不应该在终结方法或清除方法中做任何有时间限制的事情。例如，依赖于终结方法或清除方法来关闭文件是一个严重的错误，因为打开的文件描述符是有限的资源。如果由于系统在运行终结方法或清除方法时的延迟而导致许多文件处于打开状态，则程序可能会因为无法再打开文件而失败。

终结方法或清除方法执行的速度主要依赖垃圾收集算法的功能，而这个功能在不同的实现中差别很大。所以，依赖于终结方法或清除方法执行的快速性的程序的行为同样会有差异。因此，同样一个程序在你测试的JVM中完美运行，然后却在你最重要的客户上的机器上不幸地失败了，这种情况是完全有可能发生的。

缓慢的终结方法不只是一个理论上的难题。为类提供终结方法可能会随意地延迟自己的实例的回收。一位同事调试了一个长期运行的GUI应用程序，该应用程序因`OutOfMemoryError`而奇怪地崩溃过。分析显示，在应用程序崩溃的时候，它的终结方法的队列中有数千个图形对象等待被终结并回收。不幸的是，终结方法的线程以一个比其他的应用线程要更低的优先级运行着，因此对象没有在他们可以被终结的时候被终结掉。Java语言规范没有明确说明哪个线程将执行终结方法，因此除了避免使用终结方法之外，没有其他更方便的方法来防止这类问题。在这方面，清除方法比终结方法好一点，因为类作者可以控制自己的清除方法，但是清除方法仍然在后台运行，在垃圾收集器的控制下，所以不能保证及时清理。 
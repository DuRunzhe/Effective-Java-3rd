## 避免创建不必要的对象

重用一个对象常常是比较恰当的，而不是在每次需要时都去创建一个新且功能上一样的对象。 重用既比较快又比较流行。如果一个对象是不可变的(项目17)，那么它总是可以被重用的。

作为“不做什么”的极端例子，请考虑下面这句话:

```java
String s = new String("bikini"); // DON'T DO THIS!
```

这个语句在每次执行时都会创建一个新的字符串实例，而这些对象创建其实都是不必要的。字符串构造函数String(“bikini”)的参数本身就是一个字符串实例，与构造函数创建的所有对象功能相同。如果这种用法出现在一个循环语句中或一个被频繁调用的方法中，那么可能会创建百万个没必要的String实例。

改进后的版本简单如下:

```java
String s = "bikini";
```

这个版本使用单个的字符串实例，而不是每次执行时创建一个新的。此外，可以保证对象将被运行在同一虚拟机(碰巧包含相同字符串字面量)中的任何其他正在

运行的代码重用。通常可以通过使用静态工厂方法(第1项)来避免创建不必要的对象，而不是在提供这两种方法的不可变类上使用构造函数。例如，工厂方法Boolean.valueOf(String)比构造函数Boolean(String)更可取，后者在Java 9中已经被弃用。每一次调用构造方法，一定会创建一个新的对象，然而工厂方法完全没必要这么做，而且实践当中也不会这么做。除了重用不可变对象之外，如果你知道不会修改这个可变对象，那么你也可以重用这个可变对象。

有些对象创建要比其他对象昂贵得多。如果你以后会反复需要这样一个“昂贵的对象”，那么最好将其缓存以供重用。 不幸的是，在创建这样的对象时，并不总是显而易见的。假设你想写一个方法来确定字符串是否是有效的罗马数字。这里有个最简单的方法就是，使用正则表达式来做这件事情：

```java
// Performance can be greatly improved!
static boolean isRomanNumeral(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```

这个实现的问题在于它依赖于String.matches方法。虽然 String.matches是检查一个字符串是否匹配这个正则表达式最简单的方法，但是在性能要求苛刻的场景下，他并不适合重复使用。这样做的问题是，它会在内部为正则表达式创建一个Pattern实例，并且仅仅使用它一次，之后它就可以进行垃圾收集了。创建一个Pattern实例非常昂贵，因为它需要将正则表达式编译成一个有限状态机。

为了提高性能，显式地将正则表达式编译为一个Pattern实例(它是不可变的)，作为类初始化的一部分，缓存它，并在每次调用isRomanNumeral方法时重用同一个实例:

```java
// Reusing expensive object for improved performance
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile("^(?=.)M*(C[MD]|D?C{0,3})"
    		+ "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    
    static boolean isRomanNumeral(String s) {
   	 	return ROMAN.matcher(s).matches();
    }
}
```

如果经常调用这个方法，那么改进版的isRomanNumeral方法提供了显著的性能收益。在我的机器上，当输入长度为8的字符串时，第一版的方法执行了1.1微秒，而改进版的方法执行了0.17微秒，比原来快了6.5倍。不仅性能得到了改善，而且可以认为代码也变得更清晰了。使用一个静态final字段来表示原本不可见的Pattern的实例，这样允许我们给这个字段取个名字，这样做比正则表达式本身可读性高多了。

如果包含改进版的isRomanNumeral方法的类被初始化了，但是没有主动调用这个方法，那么字段ROMAN依然会被没必要地初始化。当第一次调用isRomanNumeral方法时，我们可以通过惰性初始化字段的方法来消除上面的没必要地初始化。但是不推荐这样做。虽然延迟初始化的情况经常出现，但它会让实现变得复杂，并且不能带来很大的性能提升。当一个对象是不可变的时，很明显它可以安全地被重用，但是在其他情况下，它就不那么明显了，甚至是违反直觉的。考虑适配器的情况[Gamma95]，也称为视图。适配器是委托给支持对象的对象，提供另一个可选择的接口。因为适配器除了它的支持对象之外没有其他状态，所以不需要为给定对象创建一个给定适配器的多个实例。 

例如，Map接口的keySet方法返回Map对象的Set视图，其中包含映射中的所有键。很简单，似乎每个对keySet的调用都必须创建一个新的Set实例，但是在给定的Map对象上对keySet的每个调用都可能返回相同的Set实例。虽然返回的Set实例通常是可变的，但所有返回的对象在功能上是相同的: 当其中一个返回的对象发生更改时，其他的对象也会发生变化，因为它们都是由同一个Map实例支持的。虽然创建keySet视图对象的多个实例基本上是无害的，但它是不必要的，没有任何好处。
## 避免创建不必要的对象

重用一个对象常常是比较恰当的，而不是在每次需要时都去创建一个新且功能上一样的对象。 重用既比较快又比较流行。如果一个对象是不可变的(项目17)，那么它总是可以被重用的。

作为“不做什么”的极端例子，请考虑下面这句话:

```java
String s = new String("bikini"); // DON'T DO THIS!
```

这个语句在每次执行时都会创建一个新的字符串实例，而这些对象创建其实都是不必要的。字符串构造函数String(“bikini”)的参数本身就是一个字符串实例，与构造函数创建的所有对象功能相同。如果这种用法出现在一个循环语句中或一个被频繁调用的方法中，那么可能会创建百万个没必要的String实例。

改进后的版本简单如下:

```java
String s = "bikini";
```

这个版本使用单个的字符串实例，而不是每次执行时创建一个新的。此外，可以保证对象将被运行在同一虚拟机(碰巧包含相同字符串字面量)中的任何其他正在

运行的代码重用。通常可以通过使用静态工厂方法(第1项)来避免创建不必要的对象，而不是在提供这两种方法的不可变类上使用构造函数。例如，工厂方法Boolean.valueOf(String)比构造函数Boolean(String)更可取，后者在Java 9中已经被弃用。每一次调用构造方法，一定会创建一个新的对象，然而工厂方法完全没必要这么做，而且实践当中也不会这么做。除了重用不可变对象之外，如果你知道不会修改这个可变对象，那么你也可以重用这个可变对象。

有些对象创建要比其他对象昂贵得多。如果你以后会反复需要这样一个“昂贵的对象”，那么最好将其缓存以供重用。 不幸的是，在创建这样的对象时，并不总是显而易见的。假设你想写一个方法来确定字符串是否是有效的罗马数字。这里有个最简单的方法就是，使用正则表达式来做这件事情：

```java
// Performance can be greatly improved!
static boolean isRomanNumeral(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```

这个实现的问题在于它依赖于String.matches方法。虽然 String.matches是检查一个字符串是否匹配这个正则表达式最简单的方法，但是在性能要求苛刻的场景下，他并不适合重复使用。这样做的问题是，它会在内部为正则表达式创建一个Pattern实例，并且仅仅使用它一次，之后它就可以进行垃圾收集了。创建一个Pattern实例非常昂贵，因为它需要将正则表达式编译成一个有限状态机。

为了提高性能，显式地将正则表达式编译为一个Pattern实例(它是不可变的)，作为类初始化的一部分，缓存它，并在每次调用isRomanNumeral方法时重用同一个实例:

```java
// Reusing expensive object for improved performance
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile("^(?=.)M*(C[MD]|D?C{0,3})"
    		+ "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    
    static boolean isRomanNumeral(String s) {
   	 	return ROMAN.matcher(s).matches();
    }
}
```

如果经常调用这个方法，那么改进版的isRomanNumeral方法提供了显著的性能收益。在我的机器上，当输入长度为8的字符串时，第一版的方法执行了1.1微秒，而改进版的方法执行了0.17微秒，比原来快了6.5倍。不仅性能得到了改善，而且可以认为代码也变得更清晰了。使用一个静态final字段来表示原本不可见的Pattern的实例，这样允许我们给这个字段取个名字，这样做比正则表达式本身可读性高多了。

如果包含改进版的isRomanNumeral方法的类被初始化了，但是没有主动调用这个方法，那么字段ROMAN依然会被没必要地初始化。当第一次调用isRomanNumeral方法时，我们可以通过惰性初始化字段的方法来消除上面的没必要地初始化。但是不推荐这样做。虽然延迟初始化的情况经常出现，但它会让实现变得复杂，并且不能带来很大的性能提升。当一个对象是不可变的时，很明显它可以安全地被重用，但是在其他情况下，它就不那么明显了，甚至是违反直觉的。考虑适配器的情况[Gamma95]，也称为视图。适配器是委托给支持对象的对象，提供另一个可选择的接口。因为适配器除了它的支持对象之外没有其他状态，所以不需要为给定对象创建一个给定适配器的多个实例。 

例如，Map接口的keySet方法返回Map对象的Set视图，其中包含映射中的所有键。很简单，似乎每个对keySet的调用都必须创建一个新的Set实例，但是在给定的Map对象上对keySet的每个调用都可能返回相同的Set实例。虽然返回的Set实例通常是可变的，但所有返回的对象在功能上是相同的: 当其中一个返回的对象发生更改时，其他的对象也会发生变化，因为它们都是由同一个Map实例支持的。虽然创建keySet视图对象的多个实例基本上是无害的，但它是不必要的，没有任何好处。

另一种创建不必要对象的方法是自动装箱 ，它允许程序员把原生类型和原生类型的包装类混合用，并且会根据需要自动地拆箱和装箱。自动装箱使原生类型和包装类之间界限变得模糊，但是并没有消除原生类型和原生类型的包装类之间的区别。他们之间有微妙的语义差异和不那么微妙的性能差异(第61项)。考虑下面的方法，它计算所有正int值的和。思考下面的方法，计算正整数的值。为了完成计算，程序不得不使用long型的算术符，因为int不能容纳所有正int值的总和: 

```java
// Hideously slow! Can you spot the object creation?
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++)
    	sum += i;
    return sum;
}
```

虽然这个程序得到了正确的答案，但是由于一个字符的排版错误，它相对本来应有的效率要慢得很多。变量sum被声明为Long型而不是long型，这就意味着这个程序要构造2^31个不必要的Long实例（大概每一次long型i与Long类型的sum相加都会创建一个实例）。将sum声明从Long改为long运行时间从6.3秒减少到0.59秒。这个例子很清楚：**相对包装类型，优先使用原生类型，并且注意无意识地自动装箱**。

这一章不应该被误解成暗示着我们，对象的创建是昂贵的并且要避免。相反地，小对象的创建和回收是廉价的，因为他们的构造函数没有做什么明显的工作，特别是在现代JVM实现中 。创建额外的对象来增强程序的清晰度、简单性或幂等性通常是一件好事。相反，除非池中的对象非常重量级，否则通过维护自己的对象池来避免对象创建是一个坏主意。定义对象池的典型例子是数据库连接。建立连接的成本非常高，因此重用这些对象是有意义的。然而，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代JVM实现具有高度优化的垃圾收集器，它们在轻量级对象上轻松胜过此类对象池。 

这个条款的对应面是第50项——防御性复制。当前的条款说，“当应该重用一个已经存在的对象时，就不应该创建新的对象”。然而，第50条说，“当您应该创建一个新的对象时，不要重用现有的对象。”注意，在需要进行防御性复制时重用对象的惩罚远远大于不必要地创建重复对象的惩罚。如果不能在需要的地方创建防御复制，可能会导致潜在的bug和安全漏洞;而不必要地创建对象只会影响样式和性能。
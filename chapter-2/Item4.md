## 通过私有的构造方法来阻止类的实例化

有时候你可能想要写一个类，这个类仅仅是一组静态方法和静态字段。这种类的设计是很糟糕，人们喜欢用它是因为不需要通过面向对象的角度去思考，但是这种设计用起来的确是有效果。他们可以把原生类型的值或数组相关的方法分一组，就像java.lang.Math或java.util.Arrays 的方式。他们也可以把实现接口的对象相关的静态方法，包括工厂方法分一组，就想java.util.Collections一样。（从Java 8开始，你也可以在接口中放置这些方法，假设你需要修改这些方法。）最后，你还可以对final类的方法进行分组，因为这些方法不能方法子类中去实现。

把这样的工具类设计成不可实例化，是因为它的实例化是没有意义地。然而，在没有显式构造函数的情况下，编译器提供一个公共的、无参数的默认构造函数。对使用者来说，这个构造函数跟其它的没什么区别。在已发布的api中无意地看到可实例化的类是很常见的。

**试图通过使类抽象来增强非实例性是行不通的。**这个抽象类可以有子类，然后子类可以实例化。而且这会误导使用者去想要去设计一个类，然后继承这个抽象类（第19条）。然后这里有一个简单的做法来保证非实例化。只有在类不包含显示构造函数时候，默认的构造函数才会生成。所以，一个类可以通过提供私有的构造函数来做到非实例化。

```java
// Noninstantiable utility class
public class UtilityClass {
    // Suppress default constructor for noninstantiability
    private UtilityClass() {
        throw new AssertionError();
    }
... // Remainder omitted
}
```

因为显示指定构造函数是私有的，所有无法在类外面访问到。AssertionError不是必须的，但它提供了一个保障，防止构造函数在类的内部被意外调用。它保证了类在任何情况都不会被实例化。这种做法有点反常识，因为构造函数被显示地定义了，却又不能被调用。所以，早早地给它加上注释，是明智的选择。

这样做的副作用是，阻止了类被子类化。所有构造函数都必须显式或隐式地调用父类构造函数，但是子类将没有可访问的父类构造函数来调用。